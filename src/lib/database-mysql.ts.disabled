// import { getMany, getOne, insertOne, updateOne, deleteOne, executeQuery } from './mysql' // Disabled for build

// Type definitions
export interface BlogPost {
  id: number
  title: string
  slug: string
  content: string
  excerpt?: string
  featured_image_url?: string
  author: string
  published: boolean
  status: 'draft' | 'published' | 'scheduled'
  publish_date?: string
  category?: string
  views: number
  tags: string[]
  created_at: string
  updated_at: string
}

export interface FAQ {
  id: number
  question: string
  answer: string
  category: string
  order_index: number
  is_active: boolean
  created_at: string
  updated_at: string
}

export interface Client {
  id: number
  serial_number: number
  issuer_client_company_name: string
  type_of_security: string
  isin_of_the_company: string
  is_active: boolean
  created_at: string
  updated_at: string
}

export interface ContactSubmission {
  id: number
  name: string
  email: string
  phone?: string
  company?: string
  service?: string
  message: string
  status: 'new' | 'in_progress' | 'resolved' | 'closed'
  source: string
  newsletter: boolean
  created_at: string
}

export interface NewsletterSubscription {
  id: number
  email: string
  subscribed_at: string
  is_active: boolean
  source: string
}

export class DatabaseService {
  
  // Blog operations
  static async getAllBlogPosts(): Promise<BlogPost[]> {
    const blogs = await getMany('SELECT * FROM blog_posts ORDER BY created_at DESC')
    return blogs.map(blog => ({
      ...blog,
      tags: blog.tags ? JSON.parse(blog.tags) : []
    }))
  }

  static async getBlogPosts(): Promise<BlogPost[]> {
    const blogs = await getMany('SELECT * FROM blog_posts WHERE published = TRUE ORDER BY created_at DESC')
    return blogs.map(blog => ({
      ...blog,
      tags: blog.tags ? JSON.parse(blog.tags) : []
    }))
  }

  static async getBlogPost(slug: string): Promise<BlogPost | null> {
    const blog = await getOne('SELECT * FROM blog_posts WHERE slug = ? AND published = TRUE', [slug])
    if (blog) {
      return {
        ...blog,
        tags: blog.tags ? JSON.parse(blog.tags) : []
      }
    }
    return null
  }

  static async getBlogPostById(id: number): Promise<BlogPost | null> {
    const blog = await getOne('SELECT * FROM blog_posts WHERE id = ?', [id])
    if (blog) {
      return {
        ...blog,
        tags: blog.tags ? JSON.parse(blog.tags) : []
      }
    }
    return null
  }

  static async createBlogPost(post: Omit<BlogPost, 'id' | 'created_at' | 'updated_at'>): Promise<BlogPost> {
    const data = {
      ...post,
      tags: JSON.stringify(post.tags || [])
    }
    
    const result = await insertOne('blog_posts', data)
    if (result.success) {
      return await this.getBlogPostById(result.insertId)
    }
    throw new Error('Failed to create blog post')
  }

  static async updateBlogPost(id: number, updates: Partial<BlogPost>): Promise<BlogPost> {
    const data = {
      ...updates,
      tags: updates.tags ? JSON.stringify(updates.tags) : undefined
    }
    
    // Remove undefined values
    Object.keys(data).forEach(key => data[key] === undefined && delete data[key])
    
    const result = await updateOne('blog_posts', data, { id })
    if (result.success) {
      return await this.getBlogPostById(id)
    }
    throw new Error('Failed to update blog post')
  }

  static async deleteBlogPost(id: number): Promise<void> {
    const result = await deleteOne('blog_posts', { id })
    if (!result.success) {
      throw new Error('Failed to delete blog post')
    }
  }

  // FAQ operations
  static async getAllFAQs(): Promise<FAQ[]> {
    return await getMany('SELECT * FROM faqs ORDER BY order_index ASC')
  }

  static async getFAQs(): Promise<FAQ[]> {
    return await getMany('SELECT * FROM faqs WHERE is_active = TRUE ORDER BY order_index ASC')
  }

  static async createFAQ(faq: Omit<FAQ, 'id' | 'created_at' | 'updated_at'>): Promise<FAQ> {
    const result = await insertOne('faqs', faq)
    if (result.success) {
      return await getOne('SELECT * FROM faqs WHERE id = ?', [result.insertId])
    }
    throw new Error('Failed to create FAQ')
  }

  static async updateFAQ(id: number, updates: Partial<FAQ>): Promise<FAQ> {
    const result = await updateOne('faqs', updates, { id })
    if (result.success) {
      return await getOne('SELECT * FROM faqs WHERE id = ?', [id])
    }
    throw new Error('Failed to update FAQ')
  }

  static async deleteFAQ(id: number): Promise<void> {
    const result = await deleteOne('faqs', { id })
    if (!result.success) {
      throw new Error('Failed to delete FAQ')
    }
  }

  // Client operations
  static async getClients(): Promise<Client[]> {
    return await getMany('SELECT * FROM clients WHERE is_active = TRUE ORDER BY serial_number ASC')
  }

  static async createClient(client: Omit<Client, 'id' | 'created_at' | 'updated_at'>): Promise<Client> {
    const result = await insertOne('clients', client)
    if (result.success) {
      return await getOne('SELECT * FROM clients WHERE id = ?', [result.insertId])
    }
    throw new Error('Failed to create client')
  }

  static async updateClient(id: number, updates: Partial<Client>): Promise<Client> {
    const result = await updateOne('clients', updates, { id })
    if (result.success) {
      return await getOne('SELECT * FROM clients WHERE id = ?', [id])
    }
    throw new Error('Failed to update client')
  }

  static async deleteClient(id: number): Promise<void> {
    const result = await updateOne('clients', { is_active: false }, { id })
    if (!result.success) {
      throw new Error('Failed to delete client')
    }
  }

  // Contact operations
  static async createContactSubmission(submission: Omit<ContactSubmission, 'id' | 'created_at'>): Promise<void> {
    const result = await insertOne('contact_submissions', submission)
    if (!result.success) {
      throw new Error('Failed to create contact submission')
    }
  }

  static async getContactSubmissions(): Promise<ContactSubmission[]> {
    return await getMany('SELECT * FROM contact_submissions ORDER BY created_at DESC')
  }

  static async updateContactSubmission(id: number, updates: Partial<ContactSubmission>): Promise<ContactSubmission> {
    const result = await updateOne('contact_submissions', updates, { id })
    if (result.success) {
      return await getOne('SELECT * FROM contact_submissions WHERE id = ?', [id])
    }
    throw new Error('Failed to update contact submission')
  }

  static async deleteContactSubmission(id: number): Promise<void> {
    const result = await deleteOne('contact_submissions', { id })
    if (!result.success) {
      throw new Error('Failed to delete contact submission')
    }
  }

  // Newsletter operations
  static async subscribeToNewsletter(email: string, source: string = 'website'): Promise<void> {
    const result = await insertOne('newsletter_subscriptions', { email, source, is_active: true })
    if (!result.success) {
      throw new Error('Failed to subscribe to newsletter')
    }
  }

  static async getNewsletterSubscriptions(): Promise<NewsletterSubscription[]> {
    return await getMany('SELECT * FROM newsletter_subscriptions WHERE is_active = TRUE ORDER BY subscribed_at DESC')
  }

  static async unsubscribeFromNewsletter(email: string): Promise<void> {
    const result = await updateOne('newsletter_subscriptions', { is_active: false }, { email })
    if (!result.success) {
      throw new Error('Failed to unsubscribe from newsletter')
    }
  }
}
